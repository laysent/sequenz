import fromObject from './fromObject';
import compose from './compose';
import toList from './toList';
import { isString, empty } from './utils';

/**
 * Group elements in sequenz into different groups, each has a uniq `key` generated by `iteratee`.
 * The result of this API is a new sequenz containing the key-value pairs, where value is a list of
 * all elements that sharing the same `key`. Considering each `value` as an internal sequenz, a
 * second param can be passed in. This param will be used to generate a sequenz transformer that is
 * applied to each internal sequenz. It can be used to pick up only the required elements, and
 * terminate the sequenz iteration as soon as possible.
 *
 * @param {function(any,any):string|string} iteratee - Use to calculate the `key` value out of each
 * element. If a string is given, it will be used as the property name to get `key` from each
 * element.
 * @param {function(string):function} transformGen - Function that will generate transformer using
 * given `key`. If not provided, no transform will be applied to each internal sequenz.
 */
const groupBy = (iteratee, transformGen = empty) => {
  const mapFn = isString(iteratee) ? element => element[iteratee] : iteratee;
  return subscribe => onNext => {
    const pipeline = { };
    const result = { };
    let total = 0;
    subscribe((element, i) => {
      const key = mapFn(element, i);
      if (pipeline[key] === undefined) {
        const transform = transformGen(key);
        total += 1;
        pipeline[key] = (function (internalSubscribe) {
          let receiveNext;
          let count = -1;
          /*
           * `intervalSubscribe` returns too early, even before any element has been consumed.
           * However, since it returns a reference (i.e. an array), this reference will not be
           * changed when later more elements have been added.
           * Thus, just need to cache the `onNext` function `toList` used, so that elements later
           * can continously push in.
           *
           * This is quite a tricky implementation, as it uses sync solution to handle async
           * scenario.
           */
          result[key] = internalSubscribe(internalOnNext => { receiveNext = internalOnNext; });
          return (value) => {
            count += 1;
            if (receiveNext(value, count) === false) {
              total -= 1;
              pipeline[key] = null;
            }
          };
        }(transform ? compose(transform, toList) : toList));
      }
      if (pipeline[key]) pipeline[key](element);
      return total !== 0;
    });
    return fromObject(result)(onNext);
  };
};

export default groupBy;
